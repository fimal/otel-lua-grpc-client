// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: opentelemetry/proto/logs/v1/logs.proto

#ifndef LUA_PROTOBUF_opentelemetry_proto_logs_v1_H
#define LUA_PROTOBUF_opentelemetry_proto_logs_v1_H

#include "lua-protobuf.h"
#include <opentelemetry/proto/logs/v1/logs.pb.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <lua.h>

// register all messages in this package to a Lua state
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_open(lua_State *L);

// Message LogsData
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_LogsData_pushcopy(lua_State *L, const ::opentelemetry::proto::logs::v1::LogsData &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_LogsData_pushreference(lua_State *L, ::opentelemetry::proto::logs::v1::LogsData *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_clear(lua_State *L);

// repeated message resource_logs = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_clear_resource_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_get_resource_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_set_resource_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_size_resource_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogsData_add_resource_logs(lua_State *L);

// end of message LogsData

// Message ResourceLogs
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_pushcopy(lua_State *L, const ::opentelemetry::proto::logs::v1::ResourceLogs &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_pushreference(lua_State *L, ::opentelemetry::proto::logs::v1::ResourceLogs *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_clear(lua_State *L);

// optional message resource = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_clear_resource(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_get_resource(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_set_resource(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_has_resource(lua_State *L);

// repeated message scope_logs = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_clear_scope_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_get_scope_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_set_scope_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_size_scope_logs(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_add_scope_logs(lua_State *L);

// optional string schema_url = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_clear_schema_url(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_get_schema_url(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_set_schema_url(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ResourceLogs_has_schema_url(lua_State *L);

// end of message ResourceLogs

// Message ScopeLogs
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_pushcopy(lua_State *L, const ::opentelemetry::proto::logs::v1::ScopeLogs &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_pushreference(lua_State *L, ::opentelemetry::proto::logs::v1::ScopeLogs *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_clear(lua_State *L);

// optional message scope = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_clear_scope(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_get_scope(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_set_scope(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_has_scope(lua_State *L);

// repeated message log_records = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_clear_log_records(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_get_log_records(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_set_log_records(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_size_log_records(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_add_log_records(lua_State *L);

// optional string schema_url = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_clear_schema_url(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_get_schema_url(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_set_schema_url(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_ScopeLogs_has_schema_url(lua_State *L);

// end of message ScopeLogs

// Message LogRecord
// registers the message type with Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_open(lua_State *L);


// push a copy of the message to the Lua stack
// caller is free to use original message however she wants, but changes will not
// be reflected in Lua and vice-verse
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_pushcopy(lua_State *L, const ::opentelemetry::proto::logs::v1::LogRecord &msg);

// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
LUA_PROTOBUF_EXPORT bool lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_pushreference(lua_State *L, ::opentelemetry::proto::logs::v1::LogRecord *msg, lua_protobuf_gc_callback callback, void *data);


// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.


// constructor called from Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_new(lua_State *L);

// obtain instance from a serialized string
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_gc(lua_State *L);

// obtain serialized representation of instance
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_serialized(lua_State *L);

// clear all fields in the message
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear(lua_State *L);

// optional fixed64 time_unix_nano = 1
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_time_unix_nano(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_time_unix_nano(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_time_unix_nano(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_time_unix_nano(lua_State *L);

// optional fixed64 observed_time_unix_nano = 11
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_observed_time_unix_nano(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_observed_time_unix_nano(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_observed_time_unix_nano(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_observed_time_unix_nano(lua_State *L);

// optional enum severity_number = 2
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_severity_number(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_severity_number(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_severity_number(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_severity_number(lua_State *L);

// optional string severity_text = 3
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_severity_text(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_severity_text(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_severity_text(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_severity_text(lua_State *L);

// optional message body = 5
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_body(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_body(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_body(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_body(lua_State *L);

// repeated message attributes = 6
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_attributes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_attributes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_attributes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_size_attributes(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_add_attributes(lua_State *L);

// optional uint32 dropped_attributes_count = 7
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_dropped_attributes_count(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_dropped_attributes_count(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_dropped_attributes_count(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_dropped_attributes_count(lua_State *L);

// optional fixed32 flags = 8
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_flags(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_flags(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_flags(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_flags(lua_State *L);

// optional bytes trace_id = 9
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_trace_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_trace_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_trace_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_trace_id(lua_State *L);

// optional bytes span_id = 10
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_clear_span_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_get_span_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_set_span_id(lua_State *L);
LUA_PROTOBUF_EXPORT int lua_protobuf_opentelemetry_proto_logs_v1_LogRecord_has_span_id(lua_State *L);

// end of message LogRecord

#ifdef __cplusplus
}
#endif

#endif